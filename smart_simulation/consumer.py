import logging
import pathlib
import random
from collections import namedtuple

import numpy as np
import pandas as pd

import daiquiri
from smart_simulation.cfg_templates import customers

daiquiri.setup(
    level=logging.INFO,
    outputs=(
        daiquiri.output.Stream(
            formatter=daiquiri.formatter.ColorFormatter(
                fmt="%(asctime)s [%(levelname)s] %(name)s.%(" "funcName)s: %(message)s"
            )
        ),
    ),
)


def decide(probability: float) -> bool:
    """
    Randomly make a binary decision given the probability of decision outcome

    Args:
        probability: That a customer will consume

    Returns:
        Customer's decision

    """
    if probability < 0 or probability > 1:
        logging.exception("Probability is an invalid number. Check configuration.")
        raise ValueError
    chance = random.random()
    return chance < probability


def consume(random_function: random.random, function_params: tuple) -> int:
    """
    Consume a quantity of servings based on a number generated by a function of the Random library

    Args:
        random_function: Function for quantity number generation
        function_params: Input parameters for the function

    Returns:
        The quantity of servings consumes
    """
    try:
        quantity = random_function(*function_params)
    except TypeError:
        logging.exception(
            "function_params are invalid inputs for random_function. Check configurations."
        )
        raise
    except Exception:
        raise
    return quantity


def single_day(customer_config: namedtuple, day_of_week: int):
    """
    Generate consumption data for a customer on a single day

    Args:
        customer_config: Configuration namedtuple
        day_of_week: Day of week as an int

    Returns:
        Quantity of product consumed
    """

    if not isinstance(day_of_week, int):
        logging.exception("day must be an int.")
        raise TypeError
    if day_of_week < 0 or day_of_week > 6:
        logging.exception("day_of_week must be an int in the range 0-6, inclusive.")
        raise ValueError

    day_profile = customer_config[day_of_week]
    decision_probability = day_profile.probability
    consumption_generator = day_profile.consumption
    quantity = 0
    if decide(decision_probability):
        quantity = consume(
            consumption_generator.function, consumption_generator.parameters
        )
    return quantity


def multi_day(
    customer_number: str, days: int, start_date: str = "2020-01-01"
) -> pd.DataFrame:
    """
    Generate consumption data for a customer for a given range of days

    Args:
        start_date: Start date of time range for data creation
        customer_number: ID number of customer, which should exist in the customers config file
        days: Number of days to generate data

    Returns:
        A Pandas DataFrame of product consumption in units of serving
    """
    if not isinstance(customer_number, str):
        logging.exception("customer_number must be a string.")
        raise TypeError

    if not isinstance(days, int):
        logging.exception("days must be an int.")
        raise TypeError

    customer_config = get_customer(customer_number)
    dates = pd.date_range(start_date, periods=days, freq="D")
    servings = np.zeros(days, dtype=int)
    index = np.arange(days)
    data = {"date": dates, "servings": servings}
    consumption_servings = pd.DataFrame(data=data, index=index)

    for index, day in enumerate(consumption_servings["date"]):
        day_of_week = day.dayofweek
        consumption_servings.at[index, "servings"] = single_day(
            customer_config, day_of_week
        )
    return consumption_servings


def get_customer(customer_number):
    """
        Get a customer from the customers configuration file specified by customer number
    Args:
        customer_number: Customer number in the configuration file

    Returns:
        Customer configuration namedtuple
    """
    if customer_number in customers.customers:
        return customers.customers[customer_number]
    else:
        raise Exception(
            "Customer: "
            + customer_number
            + ", does not exist in the configuration file."
        )


def write_output(data: pd.DataFrame, directory_path: pathlib.Path, file_name: str):
    """
    Write a Pandas DataFrame to a csv given a path and file name
    Args:
        directory_path: Path to write out the file
        file_name: Name of the file
        data: Pandas DataFrame
    """
    file_name = file_name + ".csv"
    if not isinstance(data, pd.DataFrame):
        logging.exception("data must be a Pandas DataFrame.")
        raise TypeError
    data.to_csv(directory_path / file_name)


def perfect_scale(
    data: pd.DataFrame, quantity_to_weight: tuple, stock_weight: float
) -> pd.DataFrame:
    """
    Create 'perfect' scale data from a consumer's consumption behavior
    Args:
        quantity_to_weight: Consumer's standard serving size as a Random function and input parameters
        stock_weight: weight of product
        data: Consumer behavior data

    Returns: Consumer behavior data with a 'weight' column of scale measurements

    """
    weights = np.zeros(len(data.index), dtype=float)
    data["weight"] = weights
    data.at[0, "weight"] = stock_weight
    for time_step in range(1, len(data.index)):
        previous_day_weight = data.at[time_step - 1, "weight"]
        consumption_servings = data.at[time_step, "servings"]

        if consumption_servings == 0:
            data.at[time_step, "weight"] = data.at[time_step - 1, "weight"]

        serving_weight = quantity_to_weight[0](*quantity_to_weight[1])
        consumption_weight = serving_weight * consumption_servings

        if previous_day_weight == 0.0:
            previous_day_weight = stock_weight

        if consumption_weight > previous_day_weight:
            data.at[time_step, "weight"] = 0.0
        else:
            data.at[time_step, "weight"] = previous_day_weight - consumption_weight

    return data


def main():
    path = pathlib.Path.cwd() / "outputs"
    customer_behavior = multi_day(
        customer_number="0", days=365, start_date="2020-01-01"
    )
    customer_consumption = perfect_scale(
        data=customer_behavior,
        quantity_to_weight=(random.normalvariate, (0.38, 0.05)),
        stock_weight=13,
    )
    write_output(customer_consumption, path, "example.csv")
    print(customer_consumption)


if __name__ == "__main__":
    main()
